-- Demonstration of spawning at random locations on maps generated by text

local PI = 3.14159265359

local game = require 'dmlab.system.game'
-- local SCREEN = game:screenShape()
-- local SHAPE = SCREEN.buffer
local SHAPE = {width=100, height=100}

local tensor = require 'dmlab.system.tensor'
local make_map = require 'common.make_map'
local pickups = require 'common.pickups'
local texture_sets = require 'themes.texture_sets'
local custom_observations = require 'decorators.custom_observations'
local property_decorator = require 'decorators.property_decorator'


local api = {
  _properties = {
    spawn_pose = {
      x='150', 
      y='150',
      z='51',
      theta='0'
    },
    goal_position = {
      x='250',
      y='250'
    },
    view_pose = {
      x='150', 
      y='150',
      z='31.125',  --default height of player is 31.125
      roll='0',
      pitch='0',
      yaw='0'  -- this is rotation about z-axis, i.e. what agent does
    },
    top_down_height = '200'
  },
  _goal = {
    x = 0,
    y = 0,
    z = 0
  }
}

property_decorator.decorate(api)
property_decorator.addReadWrite('params', api._properties)

-- Called only once at start up. Settings not recognised by DM Lab internal
-- are forwarded through the params dictionary.
function api:init(params)
  params.mapName = params.mapName or "custom_gridmap"
  params.mapEntityLayer = params.mapEntityLayer or ""
  params.mapVariationsLayer = params.mapVariationsLayer or ""
  params.randomSeed = params.randomSeed or "1"
  params.decalFrequency = params.decalFrequency or "0.1"
  
  if (params.mapEntityLayer == "")
  then 
    -- assume we are using prebuilt map
    api._map = params.mapName
  else
    -- create a custom gridmap
    make_map.random():seed(tonumber(params.randomSeed))
    api._map = make_map.makeMap{
        mapName = params.mapName,
        mapEntityLayer = params.mapEntityLayer,
        mapVariationsLayer = params.mapVariationsLayer,
        decalFrequency = tonumber(params.decalFrequency),
        useSkybox = true,
        textureSet = texture_sets.CUSTOMIZABLE_FLOORS
    }
  end
end

-- `make_map` has default pickup types A = apple_reward and G = goal.
-- This callback is used to create pickups with those names.
function api:createPickup(classname)
  return pickups.defaults[classname]
end

-- On first call we return the name of the map. On subsequent calls we return
-- an empty string. This informs the engine to only perform a quik map restart
-- instead.
function api:nextMap()
  local mapName = api._map
  api._map = ''
  return mapName
end

function api:updateSpawnVars(spawnVars)
  if spawnVars.classname == "info_player_start" then
    -- spawnVars.origin is a string of the form "X Y Z"
    spawnVars.origin = api._properties.spawn_pose.x .. " " .. api._properties.spawn_pose.y .. " " .. api._properties.spawn_pose.z
    
    -- convert to degrees
    local degrees = tonumber(api._properties.spawn_pose.theta)*180/PI
    spawnVars.angle = tostring(degrees)
    spawnVars.randomAngleRange = "0"
  elseif spawnVars.classname == "apple_reward" then
    -- use default height of 30
    spawnVars.origin = api._properties.goal_position.x .. " " .. api._properties.goal_position.y .. " 30"
    api._goal = {x = tonumber(api._properties.goal_position.x), 
                 y = tonumber(api._properties.goal_position.y),
                 z = 30}
  end
  return spawnVars
end

-- add custom observations, this adds all DEBUG observations~~~
custom_observations.decorate(api)

-- Look from specified view_pose
local function customView()
  local info = game:playerInfo()
  local pos = {
      tonumber(api._properties.view_pose.x),
      tonumber(api._properties.view_pose.y),
      tonumber(api._properties.view_pose.z)
  }
  local look = {
    tonumber(api._properties.view_pose.roll),
    tonumber(api._properties.view_pose.pitch),
    tonumber(api._properties.view_pose.yaw)
  }
  local buffer = game:renderCustomView{
      width = SHAPE.width,
      height = SHAPE.height,
      pos = pos,                      --array of numbers
      look = look,                    --array of numbers
      renderPlayer = false,
  }
  return buffer:clone()
end

local function goalPosition()
  return tensor.DoubleTensor({api._goal.x, api._goal.y, api._goal.z})
end

local function topDownView()
  local info = game:playerInfo()
  local pos = info.pos
  pos[3] = tonumber(api._properties.top_down_height)
  local look = {90,0,0}
  local buffer = game:renderCustomView{
      width = SHAPE.width,
      height = SHAPE.height,
      pos = pos,                      --array of numbers
      look = look,                    --array of numbers
      renderPlayer = false,
  }
  return buffer:clone()
end

local function panorama()
  local function angleLook(yaw)
    local info = game:playerInfo()
    local pos = {
        tonumber(api._properties.view_pose.x),
        tonumber(api._properties.view_pose.y),
        31.125 -- default height of player
    }
    local look = game:playerInfo().angles
    look[2] = tonumber(api._properties.view_pose.theta) + yaw
    local buffer = game:renderCustomView{
        width = SHAPE.width,
        height = SHAPE.height,
        pos = pos,                      --array of numbers
        look = look,                    --array of numbers
        renderPlayer = false,
    }
    return buffer:clone()
  end
  return look
end


custom_observations.addSpec('DEBUG.CUSTOM_VIEW', 'Bytes',
                            {SHAPE.width, SHAPE.height, 3}, customView)
custom_observations.addSpec('DEBUG.TOP_DOWN_VIEW', 'Bytes',
                            {SHAPE.width, SHAPE.height, 3}, topDownView)
custom_observations.addSpec('DEBUG.PANORAMA', 'Bytes',
                            {4, SHAPE.width, SHAPE.height, 3}, panorama)
custom_observations.addSpec('DEBUG.GOAL_POSITION', 'Doubles', {3}, goalPosition)
                    
                            

return api


